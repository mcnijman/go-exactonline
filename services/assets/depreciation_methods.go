// Copyright 2018 The go-exactonline AUTHORS. All rights reserved.
//
// Use of this source code is governed by a MIT
// license that can be found in the LICENSE file.
// Code generated by gen-services.go; DO NOT EDIT.
package assets

import (
	"context"
	"fmt"
	"io/ioutil"
	"net/http"

	"github.com/mcnijman/go-exactonline/api"
	"github.com/mcnijman/go-exactonline/types"
)

// DepreciationMethodsEndpoint is responsible for communicating with
// the DepreciationMethods endpoint of the Assets service.
type DepreciationMethodsEndpoint service

// DepreciationMethods:
// Service: Assets
// Entity: DepreciationMethods
// URL: /api/v1/{division}/assets/DepreciationMethods
// HasWebhook: false
// IsInBeta: false
// Methods: GET POST PUT DELETE
// Endpoint docs: https://start.exactonline.nl/docs/HlpRestAPIResourcesDetails.aspx?name=AssetsDepreciationMethods
type DepreciationMethods struct {
	MetaData *api.MetaData `json:"__metadata,omitempty"`
	// ID: Primary key
	ID *types.GUID `json:"ID,omitempty"`

	// Amount: When the method is fixed amount, this is the periodic depreciation amount
	Amount *float64 `json:"Amount,omitempty"`

	// Code: Code of the depreciation method
	Code *string `json:"Code,omitempty"`

	// Created: Creation date
	Created *types.Date `json:"Created,omitempty"`

	// Creator: User ID of creator
	Creator *types.GUID `json:"Creator,omitempty"`

	// CreatorFullName: Name of creator
	CreatorFullName *string `json:"CreatorFullName,omitempty"`

	// DepreciationInterval: Describes the periodic interval
	DepreciationInterval *string `json:"DepreciationInterval,omitempty"`

	// Description: Description of the method
	Description *string `json:"Description,omitempty"`

	// Division: Division code
	Division *int `json:"Division,omitempty"`

	// MaxPercentage: Indicates the maximum value when using depreciation type degressive to linear
	MaxPercentage *float64 `json:"MaxPercentage,omitempty"`

	// Modified: Last modified date
	Modified *types.Date `json:"Modified,omitempty"`

	// Modifier: User ID of modifier
	Modifier *types.GUID `json:"Modifier,omitempty"`

	// ModifierFullName: Name of modifier
	ModifierFullName *string `json:"ModifierFullName,omitempty"`

	// Percentage: Degressive percentage for methods: 10 - Degressive to linear, 11 - Degressive (fixed perc. of book value), 12 - Degressive to linear (Belgium &amp; Luxembourg only). And interest percentage for method: 40 - Normal annuity method. On import: Can not be modified if depreciation method is already linked to an asset. For Belgium &amp; Luxembourg the degressive percentage is calculated as double of the linear percentage
	Percentage *float64 `json:"Percentage,omitempty"`

	// Percentage2: Linear percentage for methods: 10 - Degressive to linear, 3 - Linear depreciation (Belgium &amp; Luxembourg only), 12 - Degressive to linear (Belgium &amp; Luxembourg only). On import: Can not be modified if depreciation method is already linked to an asset
	Percentage2 *float64 `json:"Percentage2,omitempty"`

	// Periods: The total number of periods for the depreciation method. Used in combination with depreciation interval: only used when interval is periodic
	Periods *int `json:"Periods,omitempty"`

	// Type: The actual type of deprecation, such as lineair or degressive. The periodic amounts are based on this type, in combination with other fields, such as the interval and the periods
	Type *int `json:"Type,omitempty"`

	// TypeDescription: Description of Type
	TypeDescription *string `json:"TypeDescription,omitempty"`

	// Years: Determines the total number of years for the depreciation method. Used in combination with depreciation interval: only used when interval is yearly
	Years *int `json:"Years,omitempty"`
}

func (e *DepreciationMethods) GetPrimary() *types.GUID {
	return e.ID
}

func (s *DepreciationMethodsEndpoint) UserHasRights(ctx context.Context, division int, method string) (bool, error) {
	return s.client.UserHasRights(ctx, division, "assets/DepreciationMethods", method)
}

// List the DepreciationMethods entities in the provided division.
// If all is true, all the paginated results are fetched; if false, list the first page.
func (s *DepreciationMethodsEndpoint) List(ctx context.Context, division int, all bool, o *api.ListOptions) ([]*DepreciationMethods, error) {
	var entities []*DepreciationMethods
	u, _ := s.client.ResolvePathWithDivision("/api/v1/{division}/assets/DepreciationMethods", division) // #nosec
	api.AddListOptionsToURL(u, o)

	if all {
		err := s.client.ListRequestAndDoAll(ctx, u.String(), &entities)
		return entities, err
	}
	_, _, err := s.client.NewRequestAndDo(ctx, "GET", u.String(), nil, &entities)
	return entities, err
}

// Get the DepreciationMethods entitiy in the provided division.
func (s *DepreciationMethodsEndpoint) Get(ctx context.Context, division int, id *types.GUID) (*DepreciationMethods, error) {
	b, _ := s.client.ResolvePathWithDivision("/api/v1/{division}/assets/DepreciationMethods", division) // #nosec
	u, err := api.AddOdataKeyToURL(b, id)
	if err != nil {
		return nil, err
	}

	e := &DepreciationMethods{}
	_, _, requestError := s.client.NewRequestAndDo(ctx, "GET", u.String(), nil, e)
	return e, requestError
}

// New returns an empty DepreciationMethods entity
func (s *DepreciationMethodsEndpoint) New() *DepreciationMethods {
	return &DepreciationMethods{}
}

// Create the DepreciationMethods entity in the provided division.
func (s *DepreciationMethodsEndpoint) Create(ctx context.Context, division int, entity *DepreciationMethods) (*DepreciationMethods, error) {
	u, _ := s.client.ResolvePathWithDivision("/api/v1/{division}/assets/DepreciationMethods", division) // #nosec
	e := &DepreciationMethods{}
	_, _, err := s.client.NewRequestAndDo(ctx, "POST", u.String(), entity, e)
	if err != nil {
		return nil, err
	}
	return e, nil
}

// Update the DepreciationMethods entity in the provided division.
func (s *DepreciationMethodsEndpoint) Update(ctx context.Context, division int, entity *DepreciationMethods) (*DepreciationMethods, error) {
	b, _ := s.client.ResolvePathWithDivision("/api/v1/{division}/assets/DepreciationMethods", division) // #nosec
	u, err := api.AddOdataKeyToURL(b, entity.GetPrimary())
	if err != nil {
		return nil, err
	}

	e := &DepreciationMethods{}
	_, _, requestError := s.client.NewRequestAndDo(ctx, "PUT", u.String(), entity, e)
	return e, requestError
}

// Delete the DepreciationMethods entity in the provided division.
func (s *DepreciationMethodsEndpoint) Delete(ctx context.Context, division int, id *types.GUID) error {
	b, _ := s.client.ResolvePathWithDivision("/api/v1/{division}/assets/DepreciationMethods", division) // #nosec
	u, err := api.AddOdataKeyToURL(b, id)
	if err != nil {
		return err
	}

	_, r, requestError := s.client.NewRequestAndDo(ctx, "DELETE", u.String(), nil, nil)
	if requestError != nil {
		return requestError
	}

	if r.StatusCode != http.StatusNoContent {
		body, _ := ioutil.ReadAll(r.Body) // #nosec
		return fmt.Errorf("Failed with status %v and body %v", r.StatusCode, body)
	}

	return nil
}
