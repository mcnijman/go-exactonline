// Copyright 2018 The go-exactonline AUTHORS. All rights reserved.
//
// Use of this source code is governed by a MIT
// license that can be found in the LICENSE file.
// Code generated by gen-services.go; DO NOT EDIT.
package cashflow

import (
	"context"
	"fmt"
	"io/ioutil"
	"net/http"

	"github.com/mcnijman/go-exactonline/api"
	"github.com/mcnijman/go-exactonline/types"
)

// AllocationRuleEndpoint is responsible for communicating with
// the AllocationRule endpoint of the Cashflow service.
type AllocationRuleEndpoint service

// AllocationRule:
// Service: Cashflow
// Entity: AllocationRule
// URL: /api/v1/beta/{division}/cashflow/AllocationRule
// HasWebhook: false
// IsInBeta: true
// Methods: GET POST PUT DELETE
// Endpoint docs: https://start.exactonline.nl/docs/HlpRestAPIResourcesDetails.aspx?name=CashflowAllocationRule
type AllocationRule struct {
	MetaData *api.MetaData `json:"__metadata,omitempty"`
	// ID: Primary key
	ID *types.GUID `json:"ID,omitempty"`

	// Account: The account ID to which the imported bank transaction must be allocated.
	Account *types.GUID `json:"Account,omitempty"`

	// AccountBankAccount: The bank account number that should be in the imported bank transaction in order to perform the automatic allocation on bank account. Either bank account or word must be filled.
	AccountBankAccount *string `json:"AccountBankAccount,omitempty"`

	// Costcenter: The cost centre that will be allocated to the imported bank transaction.
	Costcenter *string `json:"Costcenter,omitempty"`

	// Costunit: The cost unit that will be allocated to the imported bank transaction.
	Costunit *string `json:"Costunit,omitempty"`

	// Created: Creation date
	Created *types.Date `json:"Created,omitempty"`

	// Creator: User ID of creator
	Creator *types.GUID `json:"Creator,omitempty"`

	// Division: Division Code
	Division *int `json:"Division,omitempty"`

	// GLAccount: The G/L account to which the imported bank transaction must be allocated.
	GLAccount *types.GUID `json:"GLAccount,omitempty"`

	// Modified: Last modified date
	Modified *types.Date `json:"Modified,omitempty"`

	// Modifier: User ID of modifier
	Modifier *types.GUID `json:"Modifier,omitempty"`

	// VATCode: The VAT code that will be allocated to the imported bank transaction.
	VATCode *string `json:"VATCode,omitempty"`

	// Words: Words for the automatic allocation. Either bank account or word must be filled.
	Words *string `json:"Words,omitempty"`
}

func (e *AllocationRule) GetPrimary() *types.GUID {
	return e.ID
}

func (s *AllocationRuleEndpoint) UserHasRights(ctx context.Context, division int, method string) (bool, error) {
	return s.client.UserHasRights(ctx, division, "cashflow/AllocationRule", method)
}

// List the AllocationRule entities in the provided division.
// If all is true, all the paginated results are fetched; if false, list the first page.
func (s *AllocationRuleEndpoint) List(ctx context.Context, division int, all bool, o *api.ListOptions) ([]*AllocationRule, error) {
	var entities []*AllocationRule
	u, _ := s.client.ResolvePathWithDivision("/api/v1/beta/{division}/cashflow/AllocationRule", division) // #nosec
	api.AddListOptionsToURL(u, o)

	if all {
		err := s.client.ListRequestAndDoAll(ctx, u.String(), &entities)
		return entities, err
	}
	_, _, err := s.client.NewRequestAndDo(ctx, "GET", u.String(), nil, &entities)
	return entities, err
}

// Get the AllocationRule entitiy in the provided division.
func (s *AllocationRuleEndpoint) Get(ctx context.Context, division int, id *types.GUID) (*AllocationRule, error) {
	b, _ := s.client.ResolvePathWithDivision("/api/v1/beta/{division}/cashflow/AllocationRule", division) // #nosec
	u, err := api.AddOdataKeyToURL(b, id)
	if err != nil {
		return nil, err
	}

	e := &AllocationRule{}
	_, _, requestError := s.client.NewRequestAndDo(ctx, "GET", u.String(), nil, e)
	return e, requestError
}

// New returns an empty AllocationRule entity
func (s *AllocationRuleEndpoint) New() *AllocationRule {
	return &AllocationRule{}
}

// Create the AllocationRule entity in the provided division.
func (s *AllocationRuleEndpoint) Create(ctx context.Context, division int, entity *AllocationRule) (*AllocationRule, error) {
	u, _ := s.client.ResolvePathWithDivision("/api/v1/beta/{division}/cashflow/AllocationRule", division) // #nosec
	e := &AllocationRule{}
	_, _, err := s.client.NewRequestAndDo(ctx, "POST", u.String(), entity, e)
	if err != nil {
		return nil, err
	}
	return e, nil
}

// Update the AllocationRule entity in the provided division.
func (s *AllocationRuleEndpoint) Update(ctx context.Context, division int, entity *AllocationRule) (*AllocationRule, error) {
	b, _ := s.client.ResolvePathWithDivision("/api/v1/beta/{division}/cashflow/AllocationRule", division) // #nosec
	u, err := api.AddOdataKeyToURL(b, entity.GetPrimary())
	if err != nil {
		return nil, err
	}

	e := &AllocationRule{}
	_, _, requestError := s.client.NewRequestAndDo(ctx, "PUT", u.String(), entity, e)
	return e, requestError
}

// Delete the AllocationRule entity in the provided division.
func (s *AllocationRuleEndpoint) Delete(ctx context.Context, division int, id *types.GUID) error {
	b, _ := s.client.ResolvePathWithDivision("/api/v1/beta/{division}/cashflow/AllocationRule", division) // #nosec
	u, err := api.AddOdataKeyToURL(b, id)
	if err != nil {
		return err
	}

	_, r, requestError := s.client.NewRequestAndDo(ctx, "DELETE", u.String(), nil, nil)
	if requestError != nil {
		return requestError
	}

	if r.StatusCode != http.StatusNoContent {
		body, _ := ioutil.ReadAll(r.Body) // #nosec
		return fmt.Errorf("Failed with status %v and body %v", r.StatusCode, body)
	}

	return nil
}
